svc's port and namespace issue 


The master key in SQL Server is a database-level object used to secure other keys and sensitive data, such as certificates and credentials. It serves as the root of the encryption hierarchy within a database. The master key is protected by a password and is required for certain operations involving encryption and security.

Logins must be identical (in terms of name, SID, and password) across AG or DAG replicas to avoid authentication failures, orphaned users, and operational disruptions.
When you create a login with the same name and password on both replicas using CREATE LOGIN, SQL Server assigns a new SID to the login unless explicitly specified.
In most cases:
If the SID differs between the replicas but you haven't mapped any specific database users to these logins, you may not encounter issues immediately.
However, mismatched SIDs may lead to orphaned users when database failover occurs, as the user in the database might not be properly linked to the login on the secondary replica.
How to Ensure Future Consistency
For a more robust setup, consider synchronizing the SID for critical logins:
Extract SID from Primary:
SELECT name, sid 
FROM sys.sql_logins 
WHERE name = 'YourLoginName';
Create Login on Secondary with SID: Use the extracted SID when creating the login:
CREATE LOGIN YourLoginName WITH PASSWORD = 'YourPassword', SID = 0xABCDEF1234567




Ah, now I see the root cause from the error logs. The key error is:

￼
Copy
Database Mirroring login attempt failed with error: 'Connection handshake failed. The certificate used by the peer is invalid due to the following reason: Certificate not found. State 89.'
This indicates there's a certificate authentication issue between the replicas. For Distributed AG to work, we need to:

Create certificates on both instances
Exchange certificates between the instances
Create logins from the certificates






Yes, for Distributed Availability Groups (DAG), you need to ensure consistent authentication across both AG replicas (ag1 and ag2). This means:

Same DBM Login and Password: 
sql
￼
Copy
-- Use the same on both ag1 and ag2
CREATE LOGIN dbm_login WITH PASSWORD = '<same_password>';
Same Master Key Encryption Password:
sql
￼
Copy
-- Use the same master key password on both ag1 and ag2
CREATE MASTER KEY ENCRYPTION BY PASSWORD = '<same_master_key_password>';
Same Certificate Configuration: From your code, you're using dbm_certificate as the certificate name:
sql
￼
Copy
-- Certificate and endpoint configuration should match on both AGs
CREATE CERTIFICATE dbm_certificate FROM FILE = '<pfx_path>' 
WITH FORMAT = 'PFX', PRIVATE KEY (DECRYPTION BY PASSWORD = '');

CREATE ENDPOINT Hadr_endpoint
    AS TCP (LISTENER_IP = (0.0.0.0), LISTENER_PORT = 5022)
    FOR DATA_MIRRORING (
        ROLE = ALL,
        AUTHENTICATION = CERTIFICATE dbm_certificate,
        ENCRYPTION = REQUIRED ALGORITHM AES
    );
The issue in your current setup is that each AG has its own independent authentication setup. For DAG to work:

Both AGs must use identical login credentials
The master key encryption password must be the same
The certificates used for endpoint authentication must be the same
The endpoint configurations must match
Would you like me to provide a complete script to ensure consistent authentication across both AGs?




























Prepare Demo: 
TDS FDW stands for "Tabular Data Stream Foreign Data Wrapper.



PG: Add new PG instance (include TDS FSW), Connect to the instance from PC 

psql -U postgres

CREATE DATABASE ramdor;
\c ramdor

CREATE EXTENSION tds_fdw;

SELECT oid, extname, extversion FROM pg_extension;

CREATE SERVER tds_server
  FOREIGN DATA WRAPPER tds_fdw
  OPTIONS (servername 'mssql-standalone', port '1433', database 'sales', tds_version '7.4');

CREATE USER MAPPING FOR postgres
  SERVER tds_server
  OPTIONS (username 'sa', password 'Hh9Zt5FrOTzLGf3T');



IMPORT FOREIGN SCHEMA dbo
  FROM SERVER tds_server
  INTO public;



CREATE FOREIGN TABLE sqlserver_customers (
    id INTEGER,
    name VARCHAR,
    city VARCHAR
)
SERVER tds_server
OPTIONS (schema_name 'dbo', table_name 'customers');


// doesn't work 
INSERT INTO sqlserver_customers (id, name, city)
VALUES (2, 'AlicePG', 'New York');


SELECT * FROM sqlserver_customers;





MS: Connect the instance to SQL Server (TDF FDW) 
Necessary changes on sql server end:

1> create database sales;
2> go
1> use sales
2> go
Changed database context to 'sales'.
1> CREATE TABLE dbo.customers (
2>     id INT PRIMARY KEY,
3>     name NVARCHAR(100),
4>     city NVARCHAR(100)
5> );
6> go

INSERT INTO customers (id, name, city) VALUES (1, 'AliceSQL', 'New York');


ALTER ROLE db_owner ADD MEMBER sa;
sqcmd -S <SQL_SERVER_IP> -p 1433 -U sa -P '<Password>' -D sales
TDS Version Compatibility: tds_version '7.1' is not recommended, use tds_version '7.4'



PG: Upgrade PG, Change settings (Max connections), Increase RAM/CPU, Backup/Restore, HA cluster + FO 






Pod Dashboard: 
Pod Name (md, mg)
Uptime (md mg 
Version (md)
QPS(md mg 
Latency mg
Buffer pool size md 
CPU 
Memory 
Open file descriptors
Connections md mg 
Command Operations Queries mg 
Networks
Aborted Connections 
Client Thread Activity 
Thread Cache 
Last Scrape Durations / Other Scrapes 

Pod Status Running 
Role (master, slave) 
My master 
My slaves 




Database Dashboard:
instance , pod, podname
UP, Uptime
QPS(md mg 
Latency mg
Buffer pool size md 
CPU 
Memory 
Open file descriptors
Connections md mg 
Command Operations Queries mg 
Networks
Aborted Connections 

Cluster Name, 
Cluster Members 
Primary Node 
Replication Delay / Latency / Lag 
Cluster Size by each pod (joined with how my nodes)
Cluster Status (Prmary, Secondary, Secondary to pods)
Last Election 

 
Pod Status Running 
Podwise Role (master, slave) 
My slaves
Mode 



Postgres Pod: 
up,
role,
connections  
cpu
memory 
file descriptors


Postgres DB: (By selecting one database)
QPS
Transactions 
Active Sessions 
Rows 




30 sec lage petset create hoite, for standalone: 2:30 lage ready hoite 



0813 10:34:31.440187       1 secret.go:381] "Secret: demo/mssqlserver-ag-dbm-login created" mssqlserver="demo/mssqlserver-ag"
I0813 10:34:31.446465       1 client.go:84] Creating /v1, Kind=Secret demo/mssqlserver-ag-master-key.
I0813 10:34:31.454100       1 secret.go:381] "Secret: demo/mssqlserver-ag-master-key created" mssqlserver="demo/mssqlserver-ag"
I0813 10:35:12.233541       1 client.go:84] Creating apps.k8s.appscode.com/v1, Kind=PetSet demo/mssqlserver-ag.
I0813 10:35:12.263051       1 petset.go:162] "PetSet demo/mssqlserver-ag created" mssqlserver="demo/mssqlserver-ag"



(null): The configuration file '/var/opt/mssql/mssql.conf' failed to load (error: Line 0: The INI file is formatted incorrectly.  File must contain at least one section.).


